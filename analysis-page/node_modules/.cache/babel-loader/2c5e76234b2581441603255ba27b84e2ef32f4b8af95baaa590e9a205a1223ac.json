{"ast":null,"code":"var _jsxFileName = \"/Users/kokofan/Documents/project/CS529HW1/src/Whitehat.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useMemo } from 'react';\nimport useSVGCanvas from './useSVGCanvas.js';\nimport * as d3 from 'd3';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Whitehat(props) {\n  _s();\n  //this is a generic component for plotting a d3 plot\n  const d3Container = useRef(null);\n  //this automatically constructs an svg canvas the size of the parent container (height and width)\n  //tTip automatically attaches a div of the class 'tooltip' if it doesn't already exist\n  //this will automatically resize when the window changes so passing svg to a useeffect will re-trigger\n  const [svg, height, width, tTip] = useSVGCanvas(d3Container);\n  var isZoomed = false;\n\n  // console.log(\"props.cityPop\", props.cityPop);\n  const cityPopDic = {};\n  for (var d in props.cityPop) {\n    // console.log(props.cityPop[d]);\n    var cityname = props.cityPop[d].city;\n    cityPopDic[cityname] = props.cityPop[d].total_population;\n  }\n  console.log(\"cityPopDic\", cityPopDic);\n\n  //TODO: change the line below to change the size of the white-hat maximum bubble size\n  // const maxRadius = width/100;\n  const maxRadius = width / 100;\n  const margin = 50;\n\n  //albers usa projection puts alaska in the corner\n  //this automatically convert latitude and longitude to coordinates on the svg canvas\n  const projection = d3.geoAlbersUsa().translate([width / 2, height / 2]);\n\n  //set up the path generator to draw the states\n  const geoGenerator = d3.geoPath().projection(projection);\n\n  //we need to use this function to convert state names into ids so we can select individual states by name using javascript selectors\n  //since spaces makes it not work correctly\n  function cleanString(string) {\n    return string.replace(' ', '_').replace(' ', '_');\n  }\n\n  //This is the main loop that renders the code once the data loads\n  //TODO: edit or replace this code to create your white-hat version of the map view; for example, change the color map based on colorbrewer2, \n  const mapGroupSelection = useMemo(() => {\n    //wait until the svg is rendered and data is loaded\n    if (svg !== undefined & props.map !== undefined & props.data !== undefined) {\n      const stateData = props.data.states;\n\n      //EDIT THIS TO CHANGE WHAT IS USED TO ENCODE COLOR\n      const getEncodedFeature = d => d.count / d.population * 100000;\n\n      //this section of code sets up the colormap\n      const stateCounts = Object.values(stateData).map(getEncodedFeature);\n\n      //get color extends for the color legend\n      const [stateMin, stateMax] = d3.extent(stateCounts);\n\n      //color map scale, scales numbers to a smaller range to use with a d3 color scale\n      //we're using 1-0 to invert the red-yellow-green color scale\n      //so red is bad (p.s. this is not a good color scheme still)\n      const stateScale = d3.scaleLinear().domain([stateMin, stateMax]).range([1, 0]);\n\n      //TODO: EDIT HERE TO CHANGE THE COLOR SCHEME\n      //this function takes a number 0-1 and returns a color\n      // const colorMap = d3.interpolateRdYlGn; d3.scaleLinear()\n      // const colorMap = d3.scaleLog()\n      //     .range(['#6baed6','white']);\n      // const colorMap = d3.scalePow([0, 100], [\"#6baed6\", \"white\"]).exponent(2);\n      const colorMap = d3.scaleLinear()\n      // .domain([stateMin, stateMax])\n      .range(['white', '#084594'].reverse());\n\n      // const colorMap = d3.scaleOrdinal(['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'])\n      // .domain([1, 2, 3, 4, 5, 6, 9,16]);\n\n      //this set of functions extracts the features given the state name from the geojson\n      function getCount(name) {\n        //map uses full name, dataset uses abreviations\n        name = cleanString(name);\n        let entry = stateData.filter(d => d.state === name);\n        if (entry === undefined | entry.length < 1) {\n          return 0;\n        }\n        return getEncodedFeature(entry[0]);\n      }\n      function get_attris(name) {\n        //map uses full name, dataset uses abreviations\n        name = cleanString(name);\n        let entry = stateData.filter(d => d.state === name);\n        if (entry === undefined | entry.length < 1) {\n          return 0;\n        }\n        return [entry[0].count, entry[0].population, entry[0].male_count];\n      }\n      function getStateVal(name) {\n        let count = getCount(name);\n        let val = stateScale(count);\n        return val;\n      }\n      function getStateColor(d) {\n        return colorMap(getStateVal(d.properties.NAME));\n      }\n\n      //clear earlier drawings\n      svg.selectAll('g').remove();\n\n      //OPTIONAL: EDIT THIS TO CHANGE THE DETAILS OF HOW THE MAP IS DRAWN\n      //draw borders from map and add tooltip\n      let mapGroup = svg.append('g').attr('class', 'mapbox');\n      mapGroup.selectAll('path').filter('.state').data(props.map.features).enter().append('path').attr('class', 'state')\n      //ID is useful if you want to do brushing as it gives you a way to select the path\n      .attr('id', d => cleanString(d.properties.NAME)).attr('d', geoGenerator).attr('fill', getStateColor).attr('stroke', 'black').attr('stroke-width', 0.2).on('mouseover', (e, d) => {\n        let state = cleanString(d.properties.NAME);\n        //this updates the brushed state\n        if (props.brushedState !== state) {\n          props.setBrushedState(state);\n        }\n        let sname = d.properties.NAME;\n        let count = getCount(sname).toFixed(3);\n        let attrs = get_attris(sname);\n        let text = 'State: ' + sname + '</br>' + '</br>' + 'Gun Deaths: ' + attrs[0] + '</br>' + 'Male Deaths: ' + attrs[2] + '</br>' + 'Population: ' + attrs[1] + '</br>' + 'Deaths/Population: ' + count + '</br>';\n        tTip.html(text);\n      }).on('mousemove', e => {\n        //see app.js for the helper function that makes this easier\n        props.ToolTip.moveTTipEvent(tTip, e);\n      }).on('mouseout', (e, d) => {\n        props.setBrushedState();\n        props.ToolTip.hideTTip(tTip);\n      });\n\n      //TODO: replace or edit the code below to change the city marker being used. Hint: think of the cityScale range (perhaps use area rather than radius). \n      //draw markers for each city\n      const cityData = props.data.cities;\n      // const range\n      const cityMax = d3.max(cityData.map(d => d.count));\n      // const cityScale = d3.scaleLinear()\n      // const cityScale = d3.scaleSqrt()\n      const cityScale = d3.scaleSqrt().domain([0, cityMax]).range([0, maxRadius]); // \n\n      // console.log(\"keys:\", Object.keys(cityPopDic));\n\n      // for (let d in cityData) {\n      //     if (cityPopDic[cityData[d].city] !== undefined){\n      //         console.log('city: ', cityPopDic[cityData[d].id]);\n      //     }\n      // }\n\n      mapGroup.selectAll('.city').remove();\n\n      //TODO: Add code for a tooltip when you mouse over the city (hint: use the same code for the state tooltip events .on... and modify what is used for the tTip.html)\n      //OPTIONAL: change the color or opacity\n      mapGroup.selectAll('.city').data(cityData).enter().append('circle').attr('class', 'city').attr('id', d => d.city).attr('cx', d => projection([d.lng, d.lat])[0]).attr('cy', d => projection([d.lng, d.lat])[1]).attr('r', d => cityScale(d.count)).attr('fill', '#9C240A').attr('opacity', .4).attr('stroke', 'black').attr('stroke-width', 0).on('mouseover', (e, d) => {\n        let city = cleanString(d.city);\n        //this updates the brushed state\n        if (props.brushedState !== city) {\n          props.setBrushedState(city);\n        }\n        let text = 'City: ' + d.city + '</br>' + '</br>' + 'Gun-Deaths: ' + d.count + '</br>' + 'Male Deaths: ' + d.male_count + '</br>' + 'Female Deaths: ' + (d.count - d.male_count) + '</br>';\n        tTip.html(text);\n      }).on('mousemove', e => {\n        //see app.js for the helper function that makes this easier\n        props.ToolTip.moveTTipEvent(tTip, e);\n      }).on('mouseout', (e, d) => {\n        props.setBrushedState();\n        props.ToolTip.hideTTip(tTip);\n      });\n\n      //draw a color legend, automatically scaled based on data extents\n      function drawLegend() {\n        let bounds = mapGroup.node().getBBox();\n        const barHeight = Math.min(height / 10, 40);\n        let legendX = bounds.x + 10 + bounds.width;\n        const barWidth = Math.min((width - legendX) / 3, 40);\n        const fontHeight = Math.min(barWidth / 2, 16);\n        // let legendY = bounds.y + 2*fontHeight;\n        let legendY = bounds.y;\n        let colorLData = [];\n        //OPTIONAL: EDIT THE VALUES IN THE ARRAY TO CHANGE THE NUMBER OF ITEMS IN THE COLOR LEGEND\n        for (let ratio of [0.1, .2, .3, .4, .5, .6, .8, .99]) {\n          let val = (1 - ratio) * stateMin + ratio * stateMax;\n          let scaledVal = stateScale(val);\n          let color = colorMap(scaledVal);\n          let entry = {\n            'x': legendX,\n            'y': legendY,\n            'value': val,\n            'color': color\n          };\n          entry.text = entry.value.toFixed(0);\n          colorLData.push(entry);\n          legendY += barHeight;\n        }\n        svg.selectAll('.legendRect').remove();\n        svg.selectAll('.legendRect').data(colorLData).enter().append('rect').attr('class', 'legendRect').attr('x', d => d.x).attr('y', d => d.y).attr('fill', d => d.color).attr('height', barHeight).attr('width', barWidth).attr('transform', 'translate(' + 0 + \", \" + margin * 2 + ')');\n        svg.selectAll('.legendText').remove();\n        const legendTitle = {\n          'x': legendX - 3 * margin,\n          'y': legendY,\n          'text': 'Gun Deaths per 100,000 Population'\n        };\n        svg.selectAll('.legendText').data([legendTitle].concat(colorLData)).enter().append('text').attr('class', 'legendText').attr('x', d => d.x + barWidth + 5).attr('y', d => d.y + barHeight / 2 + fontHeight / 4).attr('font-size', (d, i) => i == 0 ? 1.2 * fontHeight : fontHeight).text(d => d.text).attr('transform', 'translate(' + 0 + \", \" + margin * 2 + ')');\n      }\n      drawLegend();\n      return mapGroup;\n    }\n  }, [svg, props.map, props.data]);\n\n  //This adds zooming. Triggers whenever the function above finishes\n  //this section can be included in the main body but is here as an example \n  //of how to do multiple hooks so updates don't have to occur in every state\n  useMemo(() => {\n    if (mapGroupSelection === undefined) {\n      return;\n    }\n\n    //set up zooming\n    function zoomed(event) {\n      const {\n        transform\n      } = event;\n      mapGroupSelection.attr(\"transform\", transform).attr(\"stroke-width\", 1 / transform.k);\n    }\n    const zoom = d3.zoom().on(\"zoom\", zoomed);\n\n    //OPTIONAL: EDIT THIS CODE TO CHANGE WHAT HAPPENS WHEN YOU CLICK A STATE\n    //useful if you want to add brushing\n    function clicked(event, d) {\n      event.stopPropagation();\n      if (isZoomed) {\n        mapGroupSelection.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(0, 0), d3.pointer(event, svg.node()));\n      } else {\n        //get bounds of path from map\n        const [[x0, y0], [x1, y1]] = geoGenerator.bounds(d);\n        //zoom to bounds\n        mapGroupSelection.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height))).translate(-(x0 + x1) / 2, -(y0 + y1) / 2), d3.pointer(event, svg.node()));\n      }\n      //sets the zoomed state property in the main app when we click on something\n      //if we are zoomed in, unzoom instead\n      isZoomed = !isZoomed;\n      if (isZoomed) {\n        props.setZoomedState(d.properties.NAME);\n      } else {\n        props.setZoomedState(undefined);\n      }\n    }\n    mapGroupSelection.selectAll('.state').attr('cursor', 'pointer') //so we know the states are clickable\n    .on('click', clicked);\n  }, [mapGroupSelection]);\n\n  //OPTIONAL: EDIT HERE TO CHANGE THE BRUSHING BEHAVIOUR IN THE MAP WHEN MOUSING OVER A STATE\n  //WILL UPDATE WHEN THE \"BRUSHEDSTATE\" VARIABLE CHANGES\n  //brush the state by altering it's opacity when the property changes\n  //brushed state can be on the same level but that makes it harder to use in linked views\n  //so its in the parent app to simplify the \"whitehat\" part which uses linked views.\n  useMemo(() => {\n    if (mapGroupSelection !== undefined) {\n      const isBrushed = props.brushedState !== undefined;\n      mapGroupSelection.selectAll('.state').attr('opacity', isBrushed ? .4 : .8).attr('stroke-width', isBrushed ? 0.2 : 0.5);\n      mapGroupSelection.selectAll('.city').attr('opacity', isBrushed ? .2 : .4).attr('stroke-width', isBrushed ? 0.2 : 0.5);\n      if (isBrushed) {\n        mapGroupSelection.select('#' + props.brushedState).attr('opacity', 1).attr('stroke-width', 1);\n      }\n    }\n  }, [mapGroupSelection, props.brushedState]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"d3-component\",\n    style: {\n      'height': '99%',\n      'width': '99%'\n    },\n    ref: d3Container\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 352,\n    columnNumber: 9\n  }, this);\n}\n_s(Whitehat, \"IY1z98gdTh246QemP6MlitVdCfk=\", false, function () {\n  return [useSVGCanvas];\n});\n_c = Whitehat;\nvar _c;\n$RefreshReg$(_c, \"Whitehat\");","map":{"version":3,"names":["React","useRef","useMemo","useSVGCanvas","d3","jsxDEV","_jsxDEV","Whitehat","props","_s","d3Container","svg","height","width","tTip","isZoomed","cityPopDic","d","cityPop","cityname","city","total_population","console","log","maxRadius","margin","projection","geoAlbersUsa","translate","geoGenerator","geoPath","cleanString","string","replace","mapGroupSelection","undefined","map","data","stateData","states","getEncodedFeature","count","population","stateCounts","Object","values","stateMin","stateMax","extent","stateScale","scaleLinear","domain","range","colorMap","reverse","getCount","name","entry","filter","state","length","get_attris","male_count","getStateVal","val","getStateColor","properties","NAME","selectAll","remove","mapGroup","append","attr","features","enter","on","e","brushedState","setBrushedState","sname","toFixed","attrs","text","html","ToolTip","moveTTipEvent","hideTTip","cityData","cities","cityMax","max","cityScale","scaleSqrt","lng","lat","drawLegend","bounds","node","getBBox","barHeight","Math","min","legendX","x","barWidth","fontHeight","legendY","y","colorLData","ratio","scaledVal","color","value","push","legendTitle","concat","i","zoomed","event","transform","k","zoom","clicked","stopPropagation","transition","duration","call","zoomIdentity","pointer","x0","y0","x1","y1","scale","setZoomedState","isBrushed","select","className","style","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/kokofan/Documents/project/CS529HW1/src/Whitehat.js"],"sourcesContent":["import React, {useRef,useMemo} from 'react';\nimport useSVGCanvas from './useSVGCanvas.js';\nimport * as d3 from 'd3';\n\nexport default function Whitehat(props){\n    //this is a generic component for plotting a d3 plot\n    const d3Container = useRef(null);\n    //this automatically constructs an svg canvas the size of the parent container (height and width)\n    //tTip automatically attaches a div of the class 'tooltip' if it doesn't already exist\n    //this will automatically resize when the window changes so passing svg to a useeffect will re-trigger\n    const [svg, height, width, tTip] = useSVGCanvas(d3Container);\n    var isZoomed = false;\n\n    // console.log(\"props.cityPop\", props.cityPop);\n    const cityPopDic = {};\n    for (var d in props.cityPop){\n        // console.log(props.cityPop[d]);\n        var cityname = props.cityPop[d].city;\n        cityPopDic[cityname] = props.cityPop[d].total_population;\n    }\n    console.log(\"cityPopDic\", cityPopDic);\n\n    //TODO: change the line below to change the size of the white-hat maximum bubble size\n    // const maxRadius = width/100;\n    const maxRadius = width/100;\n    const margin = 50;\n\n    //albers usa projection puts alaska in the corner\n    //this automatically convert latitude and longitude to coordinates on the svg canvas\n    const projection = d3.geoAlbersUsa()\n        .translate([width/2,height/2]);\n\n    //set up the path generator to draw the states\n    const geoGenerator = d3.geoPath().projection(projection);\n\n    //we need to use this function to convert state names into ids so we can select individual states by name using javascript selectors\n    //since spaces makes it not work correctly\n    function cleanString(string){\n        return string.replace(' ','_').replace(' ','_')\n    }\n\n\n    //This is the main loop that renders the code once the data loads\n    //TODO: edit or replace this code to create your white-hat version of the map view; for example, change the color map based on colorbrewer2, \n    const mapGroupSelection = useMemo(()=>{\n        //wait until the svg is rendered and data is loaded\n        if(svg !== undefined & props.map !== undefined & props.data !== undefined){\n\n            const stateData = props.data.states;\n\n            //EDIT THIS TO CHANGE WHAT IS USED TO ENCODE COLOR\n            const getEncodedFeature = d => d.count/d.population * 100000;\n\n            //this section of code sets up the colormap\n            const stateCounts = Object.values(stateData).map(getEncodedFeature);\n\n            //get color extends for the color legend\n            const [stateMin,stateMax] = d3.extent(stateCounts);\n\n            //color map scale, scales numbers to a smaller range to use with a d3 color scale\n            //we're using 1-0 to invert the red-yellow-green color scale\n            //so red is bad (p.s. this is not a good color scheme still)\n            const stateScale = d3.scaleLinear()\n                .domain([stateMin,stateMax])\n                .range([1,0]);\n\n            //TODO: EDIT HERE TO CHANGE THE COLOR SCHEME\n            //this function takes a number 0-1 and returns a color\n            // const colorMap = d3.interpolateRdYlGn; d3.scaleLinear()\n            // const colorMap = d3.scaleLog()\n            //     .range(['#6baed6','white']);\n               // const colorMap = d3.scalePow([0, 100], [\"#6baed6\", \"white\"]).exponent(2);\n            const colorMap = d3.scaleLinear()\n                // .domain([stateMin, stateMax])\n                .range(['white','#084594'].reverse());\n\n            // const colorMap = d3.scaleOrdinal(['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#084594'])\n            // .domain([1, 2, 3, 4, 5, 6, 9,16]);\n    \n\n            //this set of functions extracts the features given the state name from the geojson\n            function getCount(name){\n                //map uses full name, dataset uses abreviations\n                name = cleanString(name);\n                let entry = stateData.filter(d=>d.state===name);\n                if(entry === undefined | entry.length < 1){\n                    return 0\n                }\n                return getEncodedFeature(entry[0]);\n            }\n\n            function get_attris(name){\n                //map uses full name, dataset uses abreviations\n                name = cleanString(name);\n                let entry = stateData.filter(d=>d.state===name);\n                if(entry === undefined | entry.length < 1){\n                    return 0\n                }\n                return [entry[0].count, entry[0].population, entry[0].male_count];\n            }\n\n            function getStateVal(name){\n                let count = getCount(name);\n                let val = stateScale(count);\n                return val\n            }\n\n            function getStateColor(d){\n                return colorMap(getStateVal(d.properties.NAME))\n            }\n\n            //clear earlier drawings\n            svg.selectAll('g').remove();\n\n            //OPTIONAL: EDIT THIS TO CHANGE THE DETAILS OF HOW THE MAP IS DRAWN\n            //draw borders from map and add tooltip\n            let mapGroup = svg.append('g').attr('class','mapbox');\n            mapGroup.selectAll('path').filter('.state')\n                .data(props.map.features).enter()\n                .append('path').attr('class','state')\n                //ID is useful if you want to do brushing as it gives you a way to select the path\n                .attr('id',d=> cleanString(d.properties.NAME))\n                .attr('d',geoGenerator)\n                .attr('fill',getStateColor)\n                .attr('stroke','black')\n                .attr('stroke-width',0.2)\n                .on('mouseover',(e,d)=>{\n                    let state = cleanString(d.properties.NAME);\n                    //this updates the brushed state\n                    if(props.brushedState !== state){\n                        props.setBrushedState(state);\n                    }\n                    let sname = d.properties.NAME;\n                    let count = getCount(sname).toFixed(3);\n                    let attrs = get_attris(sname);\n                    let text = 'State: ' + sname + '</br>'\n                        + '</br>'\n                        + 'Gun Deaths: ' + attrs[0] + '</br>'\n                        + 'Male Deaths: ' + attrs[2] + '</br>'\n                        + 'Population: ' + attrs[1] + '</br>'\n                        + 'Deaths/Population: ' + count + '</br>';\n                    tTip.html(text);\n                }).on('mousemove',(e)=>{\n                    //see app.js for the helper function that makes this easier\n                    props.ToolTip.moveTTipEvent(tTip,e);\n                }).on('mouseout',(e,d)=>{\n                    props.setBrushedState();\n                    props.ToolTip.hideTTip(tTip);\n                });\n\n\n            //TODO: replace or edit the code below to change the city marker being used. Hint: think of the cityScale range (perhaps use area rather than radius). \n            //draw markers for each city\n            const cityData = props.data.cities\n            // const range\n            const cityMax = d3.max(cityData.map(d=>d.count));\n            // const cityScale = d3.scaleLinear()\n            // const cityScale = d3.scaleSqrt()\n            const cityScale = d3.scaleSqrt()\n                .domain([0, cityMax])\n                .range([0, maxRadius]); // \n\n            // console.log(\"keys:\", Object.keys(cityPopDic));\n\n            // for (let d in cityData) {\n            //     if (cityPopDic[cityData[d].city] !== undefined){\n            //         console.log('city: ', cityPopDic[cityData[d].id]);\n            //     }\n            // }\n\n            mapGroup.selectAll('.city').remove();\n\n            //TODO: Add code for a tooltip when you mouse over the city (hint: use the same code for the state tooltip events .on... and modify what is used for the tTip.html)\n            //OPTIONAL: change the color or opacity\n            mapGroup.selectAll('.city')\n                .data(cityData).enter()\n                .append('circle').attr('class','city')\n                .attr('id',d=>d.city)\n                .attr('cx',d=> projection([d.lng,d.lat])[0])\n                .attr('cy',d=> projection([d.lng,d.lat])[1])\n                .attr('r',d=>cityScale(d.count))\n                .attr('fill', '#9C240A')\n                .attr('opacity',.4)\n                .attr('stroke', 'black')\n                .attr('stroke-width', 0)\n                .on('mouseover',(e,d)=>{\n                    let city = cleanString(d.city);\n                    //this updates the brushed state\n                    if(props.brushedState !== city){\n                        props.setBrushedState(city);\n                    }\n                    let text = 'City: ' + d.city + '</br>'\n                        + '</br>'\n                        + 'Gun-Deaths: ' + d.count + '</br>'\n                        + 'Male Deaths: ' + d.male_count + '</br>'\n                        + 'Female Deaths: ' + (d.count - d.male_count) + '</br>';\n                    tTip.html(text);\n                }).on('mousemove',(e)=>{\n                    //see app.js for the helper function that makes this easier\n                    props.ToolTip.moveTTipEvent(tTip,e);\n                }).on('mouseout',(e,d)=>{\n                    props.setBrushedState();\n                    props.ToolTip.hideTTip(tTip);\n                });               \n\n            \n            //draw a color legend, automatically scaled based on data extents\n            function drawLegend(){\n                let bounds = mapGroup.node().getBBox();\n                const barHeight = Math.min(height/10,40);\n                \n                let legendX = bounds.x + 10 + bounds.width;\n                const barWidth = Math.min((width - legendX)/3,40);\n                const fontHeight = Math.min(barWidth/2,16);\n                // let legendY = bounds.y + 2*fontHeight;\n                let legendY = bounds.y;\n                \n                let colorLData = [];\n                //OPTIONAL: EDIT THE VALUES IN THE ARRAY TO CHANGE THE NUMBER OF ITEMS IN THE COLOR LEGEND\n                for(let ratio of [0.1,.2,.3,.4,.5,.6,.8,.99]){\n                    let val = (1-ratio)*stateMin + ratio*stateMax;\n                    let scaledVal = stateScale(val);\n                    let color = colorMap(scaledVal);\n                    let entry = {\n                        'x': legendX,\n                        'y': legendY,\n                        'value': val,\n                        'color':color,\n                    }\n                    entry.text = (entry.value).toFixed(0);\n            \n                    colorLData.push(entry);\n                    legendY += barHeight;\n                }\n    \n                svg.selectAll('.legendRect').remove();\n                svg.selectAll('.legendRect')\n                    .data(colorLData).enter()\n                    .append('rect').attr('class','legendRect')\n                    .attr('x',d=>d.x)\n                    .attr('y',d=>d.y)\n                    .attr('fill',d=>d.color)\n                    .attr('height',barHeight)\n                    .attr('width',barWidth)\n                    .attr('transform', 'translate(' + 0 + \", \" + margin*2 + ')' );\n    \n                svg.selectAll('.legendText').remove();\n                const legendTitle = {\n                    'x': legendX - 3*margin,\n                    'y': legendY,\n                    'text': 'Gun Deaths per 100,000 Population'\n                }\n                svg.selectAll('.legendText')\n                    .data([legendTitle].concat(colorLData)).enter()\n                    .append('text').attr('class','legendText')\n                    .attr('x',d=>d.x+barWidth+5)\n                    .attr('y',d=>d.y+barHeight/2 + fontHeight/4)\n                    .attr('font-size',(d,i) => i == 0? 1.2*fontHeight:fontHeight)\n                    .text(d=>d.text)\n                    .attr('transform', 'translate(' + 0 + \", \" + margin*2 + ')' );\n            }\n\n            drawLegend();\n            return mapGroup\n        }\n    },[svg,props.map,props.data])\n\n    //This adds zooming. Triggers whenever the function above finishes\n    //this section can be included in the main body but is here as an example \n    //of how to do multiple hooks so updates don't have to occur in every state\n    useMemo(()=>{\n        if(mapGroupSelection === undefined){ return }\n        \n        //set up zooming\n        function zoomed(event) {\n            const {transform} = event;\n            mapGroupSelection\n                .attr(\"transform\", transform)\n               .attr(\"stroke-width\", 1 / transform.k);\n        }\n\n        const zoom = d3.zoom()\n            .on(\"zoom\", zoomed);\n\n        //OPTIONAL: EDIT THIS CODE TO CHANGE WHAT HAPPENS WHEN YOU CLICK A STATE\n        //useful if you want to add brushing\n        function clicked(event, d) {\n            event.stopPropagation();\n            if(isZoomed){\n                mapGroupSelection.transition().duration(300).call(\n                    zoom.transform,\n                    d3.zoomIdentity.translate(0,0),\n                    d3.pointer(event,svg.node())\n                )\n                    \n            }\n            else{\n                //get bounds of path from map\n                const [[x0, y0], [x1, y1]] = geoGenerator.bounds(d);\n                //zoom to bounds\n                mapGroupSelection.transition().duration(750).call(\n                    zoom.transform,\n                    d3.zoomIdentity\n                    .translate(width / 2, height / 2)\n                    .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))\n                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),\n                    d3.pointer(event, svg.node())\n                );\n            }\n            //sets the zoomed state property in the main app when we click on something\n            //if we are zoomed in, unzoom instead\n            isZoomed = !isZoomed;\n            if(isZoomed){\n                props.setZoomedState(d.properties.NAME);\n            } else{\n                props.setZoomedState(undefined);\n            }\n        }\n        \n\n        mapGroupSelection.selectAll('.state')\n            .attr('cursor','pointer')//so we know the states are clickable\n            .on('click',clicked);\n\n    },[mapGroupSelection]);\n\n    //OPTIONAL: EDIT HERE TO CHANGE THE BRUSHING BEHAVIOUR IN THE MAP WHEN MOUSING OVER A STATE\n    //WILL UPDATE WHEN THE \"BRUSHEDSTATE\" VARIABLE CHANGES\n    //brush the state by altering it's opacity when the property changes\n    //brushed state can be on the same level but that makes it harder to use in linked views\n    //so its in the parent app to simplify the \"whitehat\" part which uses linked views.\n    useMemo(()=>{\n        if(mapGroupSelection !== undefined){\n            const isBrushed = props.brushedState !== undefined;\n            mapGroupSelection.selectAll('.state')\n                .attr('opacity',isBrushed? .4:.8)\n                .attr('stroke-width',isBrushed? 0.2:0.5);\n\n            mapGroupSelection.selectAll('.city')\n                .attr('opacity',isBrushed? .2:.4)\n                .attr('stroke-width',isBrushed? 0.2:0.5);\n\n            if(isBrushed){\n                mapGroupSelection.select('#'+props.brushedState)\n                    .attr('opacity',1)\n                    .attr('stroke-width',1);\n            }\n        }\n    },[mapGroupSelection,props.brushedState]);\n    \n    return (\n        <div\n            className={\"d3-component\"}\n            style={{'height':'99%','width':'99%'}}\n            ref={d3Container}\n        ></div>\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}